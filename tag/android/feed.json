{
    "version": "https://jsonfeed.org/version/1",
    "title": "Jone's Blog • All posts by \"android\" tag",
    "description": "技术栈笔记，以及在学习过程中遇到的坎坷。",
    "home_page_url": "https://www.jone.plus",
    "items": [
        {
            "id": "https://www.jone.plus/2024/10/26/study/uniapp/uniapp-markertap/",
            "url": "https://www.jone.plus/2024/10/26/study/uniapp/uniapp-markertap/",
            "title": "Uniapp 地图标点 点击事件  markertap / bindmarkertap 不生效",
            "date_published": "2024-10-26T08:01:45.000Z",
            "content_html": "<p>Uniapp 地图标点 点击事件  markertap /bindmarkertap 不生效<br>\n先来说说 uniapp 的使用感想：<br>\n刚开始使用 uniapp 不久，使用上来说与 vue3 没有多大区别，setup 语法感觉非常舒适，使用起来方便、简易，相对于使用 flutter 、原生来说，对于小型企业来说真的是属于便利的一个跨平台框架了。<br>\n国内的现状，开发成本降低、适配平台需求较广，例如小程序 (支付宝、微信、抖音等等)、APP （android、ios）以及遥遥领先 harmony os。目前官方有说明已经大部分适配 鸿蒙，这个框架还是挺强的。<br>\n对于这种适配层面较广的框架，难免就会出现很多 BUG、兼容性适配。</p>\n<p>今天遇到的问题：</p>\n<ul>\n<li>markertap 事件不生效</li>\n<li>使用:markers 直接赋值在 map  微信开发工具正常显示、真机运行不显示</li>\n<li>使用:covers    直接赋值在 map     微信开发工具不显示、真机运行显示正常<br>\n场景：<br>\n&lt;map show-location<br>\nid=“map”<br>\n:latitude=“latitude”<br>\n:markers=“showMarker”  :covers=“showMarker”<br>\n:scale=“scale” :longitude=“longitude”<br>\n:polyline=“polyines”  name=“index-map”<br>\nstyle=“width: 100%;” :style=&quot;{height :  <code>$&#123;mapHeight&#125;px</code> }&quot;<br>\n@tap=“onMapTap”  @markertap=“onMarkerTap”&gt;<br>\n</map></li>\n</ul>\n<script setup lang=\"ts\">\n\nconst markers = ref<Map<String, Marker>>(new Map())\nconst showMarker = computed(()=> [...markers.value.values()])\n\n// 当marker 被点击的时候\nfunction onMarkerTap(e) {\n        console.log(\"====> marker 被点击\", e);\n        activeId.value = e.detail.markerId\n        roadLine()\n}\n\n\n//.....................\n</script>\n<p>遇到了 marker 不显示，后面将 markers 和 covers 都赋值在 map 组件上。最后都能看到了。于是开始解决 markertap 不生效的问题。</p>\n<p>尝试：</p>\n<ol>\n<li>使用 @markertap 绑定事件， 在微信开发者工具中可以正常运行，但是真机调试点击不了，不能正常响应</li>\n<li>使用 bindmarkertap 进行绑定，随后在微信开发者工具报错，&quot;In Component  Unabled to find onMarkerTap method to handle markertap.&quot;</li>\n</ol>\n<p>最终解决方案：<br>\n&lt;map show-location<br>\nid=“map”<br>\n:latitude=“latitude”<br>\n:scale=“scale” :longitude=“longitude”<br>\n:polyline=“polyines”  name=“index-map”<br>\nstyle=“width: 100%;” :style=&quot;{height :  <code>$&#123;mapHeight&#125;px</code> }&quot;<br>\n@tap=“onMapTap”  @markertap=“onMarkerTap”&gt;<br>\n</map></p>\n<script lang=\"ts\" scoped>\n    import { onLoad, onReady } from '@dcloudio/uni-app';\n    \n    let mapContext : UniApp.MapContext\n    function getData(){\n         //....\n         mapContext.addMarkers({\n                            markers: [...markers.value.values()],\n                            clear: true\n         } as UniApp.MapContextAddMarkersOptions)\n         //....\n    }\n    \n    onLoad(() => {\n         mapContext = uni.createMapContext(\"map\")\n    })\n    \n //....\n</script>\n<p>最终的解决方案就是将 marker 数据通过代码 手动添加到 map， 事件绑定仍然采用 @markertap  的形式去绑定。<br>\n原因暂时未知：有可能是 uniapp 在适配层没有去兼容 ，响应式 marker 数据没有绑定被点击的事件。</p>\n",
            "tags": [
                "android",
                "uniapp",
                "微信小程序"
            ]
        },
        {
            "id": "https://www.jone.plus/2023/05/22/study/android/android_base_review/",
            "url": "https://www.jone.plus/2023/05/22/study/android/android_base_review/",
            "title": "Android 基础知识巩固",
            "date_published": "2023-05-22T07:44:06.000Z",
            "content_html": "<h2 id=\"四大组件\"><a class=\"markdownIt-Anchor\" href=\"#四大组件\">#</a> 四大组件</h2>\n<h3 id=\"activity\"><a class=\"markdownIt-Anchor\" href=\"#activity\">#</a> Activity</h3>\n<h4 id=\"activity-是什么\"><a class=\"markdownIt-Anchor\" href=\"#activity-是什么\">#</a> Activity 是什么</h4>\n<p>Activity 是 Android 中重要的组件之一，它在 APP 开发中扮演者不可缺少的角色，可以说就是我们的可见界面。</p>\n<p>Activity 中包括了 UI 的展示、用户的交互设置、数据的逻辑处理等等。</p>\n<h4 id=\"activity的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#activity的生命周期\">#</a> Activity 的生命周期</h4>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"><p style=\"text-align:left;\">onCreate：当 activity 被创建会调用该方法，在该函数中会调用 setContentView (view:View) 进行界面 UI 设置。<br/> onRestart：当用户移动到其他的界面再回到该界面时会调用该函数<br/>onStart: 当走到这一周期函数时，用户可以看到界面，但是不能够进行交互<br/>onResume: 当调用该函数后，用户可以进行交互<br/>onPause：当当前界面失去焦点，但是可见时，该方法会被调用<br/>onStop：当用户离开该界面，会在离开之后的界面展示的 onStart 函数后调用<br/>onDestroy：当前 Activity 因为不使用导致系统 GC 销毁或者被手动 finish 后会被调用</p></th>\n<th><img data-src=\"https://fs.jone.plus/imgs/image-20230521220952700.png\" alt=\"image-20230521220952700\"></th>\n</tr>\n</thead>\n</table>\n<h4 id=\"activity-中-intent-是什么\"><a class=\"markdownIt-Anchor\" href=\"#activity-中-intent-是什么\">#</a> Activity 中 Intent 是什么？</h4>\n<p>Intent 常用于两个组件之间的交互，可以启动服务、启动 Activity、启动广播。也可用于 启动服务 以及 绑定服务 去与后台服务进行通信。意图实际上是提供了不同程序之间的运行时绑定，更多的使用在启动 Activity。</p>\n<p>Intent 的结构：</p>\n<ul>\n<li>\n<p>action : 可以执行一些通用的行为，例如 ACTION_VIEW、ACTION_EDIT、ACTION_MAIN</p>\n</li>\n<li>\n<p>data: 传输需要处理的数据，例如：</p>\n<p><strong> <code>ACTION_VIEW</code>  content://contacts/people/1</strong></p>\n<p><strong> <code>ACTION_DIAL</code>  content://contacts/people/1</strong></p>\n<p><strong> <code>ACTION_VIEW</code>  tel:123</strong></p>\n<p><strong> <code>ACTION_DIAL</code>  tel:123</strong></p>\n<p><strong> <code>ACTION_EDIT</code>  content://contacts/people/1</strong></p>\n<p><strong> <code>ACTION_VIEW</code>  content://contacts/people/</strong></p>\n</li>\n<li>\n<p>category ： 给定其他有关行为去执行例如： CATEGORY_LAUNCH、CATEGORY_ALTERNATIVE</p>\n</li>\n<li>\n<p>type : 生命 MINI type</p>\n</li>\n<li>\n<p>component 少用</p>\n</li>\n<li>\n<p>extra： 使用 bundle 存储额外的信息，可以在不同组件间传输少量数据</p>\n</li>\n</ul>\n<h3 id=\"service\"><a class=\"markdownIt-Anchor\" href=\"#service\">#</a> Service</h3>\n<h4 id=\"service-是什么\"><a class=\"markdownIt-Anchor\" href=\"#service-是什么\">#</a> Service 是什么？</h4>\n<p>Service 是 Android 中可以在后台执行长时运行操作而不提供界面的组件。可以由其他组件启动。并且用户切换到其他应用，服务仍然会在后台运行。</p>\n<p>此外，服务可以进行进程间通信【IPC】，常用在处理网络事务、音乐播放、执行 IO 与内容提供程序的交互。</p>\n<h4 id=\"service-的分类\"><a class=\"markdownIt-Anchor\" href=\"#service-的分类\">#</a> Service 的分类？</h4>\n<p>可以分为三种类型。</p>\n<ul>\n<li>\n<p>前台服务：前台服务执行一些用户可观测的操作，例如音频软件会使用前台服务播放。前台服务必须显示通知。即使用户停止与应用的交互，前台服务仍会继续运行。</p>\n</li>\n<li>\n<p>后台服务：后台服务执行用户不能注意到的操作，例如，如果应用使用某个服务来压缩其存储空间，则此服务通常是后台服务。</p>\n</li>\n<li>\n<p>绑定服务：当应用组件通过调用  <code>bindService()</code>  绑定到服务时，服务即处于<em>绑定</em>状态。绑定服务会提供客户端 - 服务器接口，以便组件与服务进行交互、发送请求、接收结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p>\n</li>\n</ul>\n<p><strong>有一种情况是，既可以是启动服务（以无限期运行），亦支持绑定。唯一的问题在于您是否实现一组回调方法： <code>onStartCommand()</code> （让组件启动服务）和  <code>onBind()</code> （实现服务绑定）。</strong></p>\n<h4 id=\"service-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#service-的生命周期\">#</a> Service 的生命周期</h4>\n<img data-src=\"https://fs.jone.plus/imgs/image-20230521231757499.png\" alt=\"image-20230521231757499\" style=\"zoom:50%;\" />\n<p>onStartCommand：当另一个组件调用 startService 启动服务时，该服务会启动并一直运行，直到调用 stopSelf () 或者 stopService ()</p>\n<p>onBind：当另一个组件想要与服务绑定（例如执行 RPC）时，系统会通过调用  <code>bindService()</code>  来调用此方法。在此方法的实现中，您必须通过返回  <code>IBinder</code>  提供一个接口，以供客户端用来与服务进行通信。</p>\n<p>onCreate：首次创建服务时，系统会（在调用  <code>onStartCommand()</code>  或  <code>onBind()</code>  之前）调用此方法来执行一次性设置程序。如果服务已在运行，则不会调用此方法。</p>\n<p>onDestroy：当不再使用服务且准备将其销毁时，系统会调用此方法。服务应通过实现此方法来清理任何资源，如线程、注册的侦听器、接收器等。这是服务接收的最后一个调用。</p>\n<p><strong>使用时必须在 Manifest 中注册服务</strong></p>\n<h4 id=\"intentservice\"><a class=\"markdownIt-Anchor\" href=\"#intentservice\">#</a> IntentService</h4>\n<p>intentService 是对 Service 的一个封装</p>\n<p>由于大多数启动服务无需同时处理多个请求（实际上，这种多线程情况可能很危险），因此最佳选择是利用  <code>IntentService</code>  类实现服务。</p>\n<p><code>IntentService</code>  类会执行以下操作：</p>\n<ul>\n<li>创建默认的工作线程，用于在应用的主线程外执行传递给  <code>onStartCommand()</code>  的所有 Intent。</li>\n<li>创建工作队列，用于将 Intent 逐一传递给  <code>onHandleIntent()</code>  实现，这样您就永远不必担心多线程问题。</li>\n<li>在处理完所有启动请求后停止服务，因此您永远不必调用  <code>stopSelf()</code> 。</li>\n<li>提供  <code>onBind()</code>  的默认实现（返回 null）。</li>\n<li>提供  <code>onStartCommand()</code>  的默认实现，可将 Intent 依次发送到工作队列和  <code>onHandleIntent()</code>  实现</li>\n</ul>\n<h3 id=\"broadcastreceiver\"><a class=\"markdownIt-Anchor\" href=\"#broadcastreceiver\">#</a> BroadCastReceiver</h3>\n",
            "tags": [
                "android"
            ]
        },
        {
            "id": "https://www.jone.plus/2022/10/08/study/android/android%E5%88%B7%E6%9C%BA/",
            "url": "https://www.jone.plus/2022/10/08/study/android/android%E5%88%B7%E6%9C%BA/",
            "title": "Android 刷机 | MIUI | TWRP | Root 工具集锦",
            "date_published": "2022-10-08T06:34:06.000Z",
            "content_html": "<p><img data-src=\"https://celltrackingapps.com/wp-content/uploads/2018/08/CELULAR-1-1140x445.jpg\" alt=\"\"></p>\n<hr>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUUlODklRTUlOEQlOTNST00=\">安卓 ROM</span> 是手机重新刷入系统的一个程序包，安卓系统在手机市场里占有率很高，所以安卓 ROM 发展很快，国内比较知名的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUUlODklRTUlOEQlOTNST00=\">安卓 ROM</span> 有米柚，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjklOTAlRTglOUIlOTkvMTAwODU0NjA=\">乐蛙</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclOTklQkUlRTUlQkElQTYlRTQlQkElOTEvMjQ2MjAwMA==\">百度云</span>，深度等。</p>\n<p>在 android 开发过程中和玩机体验中，时而会想获得手机授权，这里收集了一些关于 Android 机型授权的有关资源。【有些地址或许需要科学访问】</p>\n<hr>\n<h2 id=\"teamwin-twrp\"><a class=\"markdownIt-Anchor\" href=\"#teamwin-twrp\">#</a> TeamWin-TWRP</h2>\n<p><img data-src=\"https://fs.jone.plus/markdown/202210082258001.png\" alt=\"image-20221008225847926\"></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly90d3JwLm1lL0RldmljZXMv\">Devices (twrp.me)</span></p>\n<p>Recovery 神器 ，进入页面直接搜索手机型号即可。</p>\n<h2 id=\"小米-miui-red-mi\"><a class=\"markdownIt-Anchor\" href=\"#小米-miui-red-mi\">#</a> 小米 | MIUI | Red Mi</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWl1aS5jb20vdW5sb2NrL2luZGV4Lmh0bWw=\">申请解锁小米手机 (miui.com)</span></p>\n<p>[<span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIudmlwLm1pdWkuY29tL3BhZ2UvaW5mby9taW8vbWlvL2RldGFpbD9wb3N0SWQ9MTc5MzY1NzUmYW1wO2FwcF92ZXJzaW9uPWRldi4yMDA1MQ==\">教程] 小米手机解 BL 锁、线刷详细教程，适用于小米全系列手机 (miui.com)</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly94aWFvbWlyb20uY29tLw==\">XiaomiROM.com - 小米 ROM 线刷包，卡刷包的最新及历史版本下载</span></p>\n<blockquote>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cDovL1hpYW9taVJPTS5jb20=\">XiaomiROM.com</span></strong> 是一个站点，用于收集小米手机、小米平板等小米机型其国行版、全球版、欧洲版（欧版）、印度版、印度尼西亚版、俄罗斯版（俄版）、土耳其版、台湾版（台版）、日本版（日版）的小米 ROM。刷机包下载链接来自小米 ROM 官网地址，您始终可以获得全速下载。固件均为小米官方 ROM，当前没有第三方 ROM。</p>\n</blockquote>\n<h2 id=\"安卓开源系统\"><a class=\"markdownIt-Anchor\" href=\"#安卓开源系统\">#</a> 安卓开源系统</h2>\n<img data-src=\"https://www.mokeedev.com/images/logo.png\" width=\"150\"/>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubW9rZWVkZXYuY29tLw==\">魔趣 ROM (mokeedev.com)</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5tb2tlZWRldi5jb20v\">魔趣 ROM</span> 基于 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20v\">Android 开源项目 (AOSP)</span> 二次开发，所有的定制都遵循 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9hYm91dC8=\">Google</span> 推出的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9tYXRlcmlhbC5pby8=\">Material Design</span> 设计语言，与原生 Android 界面保持着一致，这种定制方式降低了版本升级的难度。相比设备制造商迟缓、不积极的更新，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3dubG9hZC5tb2tlZWRldi5jb20v\">魔趣 ROM</span> 总能紧随 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9hYm91dC8=\">Google</span>，早早为用户带来最新的 Android 系统。</p>\n<h2 id=\"常用命令\"><a class=\"markdownIt-Anchor\" href=\"#常用命令\">#</a> 常用命令</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL2NvbW1hbmQtbGluZS9hZGI/aGw9emgtY24=\">adb</span><br>\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vZG9jcy9zZXR1cC9idWlsZC9ydW5uaW5n\">fastboot</span></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">adb 操作</span></span><br><span class=\"line\">adb devices # 查看连接设备</span><br><span class=\"line\">adb shell #进入shell </span><br><span class=\"line\">adb reboot bootloader #重启进入 Fastboot 模式</span><br><span class=\"line\">adb kill-server #关闭服务</span><br><span class=\"line\">adb start #启动</span><br><span class=\"line\">adb install ****.apk #安装apk</span><br><span class=\"line\">adb push file androidfilepath # 将文件file 推送到android  eg. adb  push name.pdf /storage/emulated/0/Download</span><br><span class=\"line\">adb pull androidfilepath file # 将文件androidfilepath 拉到本地存储 </span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">fastboot 下操作</span></span><br><span class=\"line\">fastboot reboot #重启手机至recovery</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">2014 年及之前发布的设备</span></span><br><span class=\"line\">fastboot oem reboot+[模式名称] #reboot-recovery reboot-bootloader reboot-edl(高通下载模式)</span><br><span class=\"line\">fastboot oem lock # 重装上锁</span><br><span class=\"line\">fastboot oem unlock #解锁</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">2015 年及之后发布的设备</span></span><br><span class=\"line\">fastboot flashing unlock  #解锁</span><br><span class=\"line\">fastboot flashing lock  #锁</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">fastboot boot twrp-*.img #不安装 镜像的情况下  使用镜像</span><br><span class=\"line\">fastboot flash recovery twrp-*.img #flash recover 刷入镜像 </span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a class=\"markdownIt-Anchor\" href=\"#参考文章\">#</a> 参考文章</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vbmZpeC5jbi9jb3Vyc2UvMzg0NT9iaWQ9MSZhbXA7bWlkPTg=\">小米（Mi） 9 小米（Mi） 9 手机刷 TWRP 方法，刷三方 Recovery 方法（解决卡米问题）刷机解锁 (onfix.cn)</span></p>\n",
            "tags": [
                "android"
            ]
        },
        {
            "id": "https://www.jone.plus/2022/07/19/problem/android/Android-Studio%20%E4%B8%8D%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E7%89%A9%E7%90%86%E6%9C%BA/",
            "url": "https://www.jone.plus/2022/07/19/problem/android/Android-Studio%20%E4%B8%8D%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E7%89%A9%E7%90%86%E6%9C%BA/",
            "title": "【linux】 Android-Studio 不能检测到物理机",
            "date_published": "2022-07-18T16:16:28.000Z",
            "content_html": "<h1 id=\"android-studio-不能够检测到真机物理机\"><a class=\"markdownIt-Anchor\" href=\"#android-studio-不能够检测到真机物理机\">#</a> Android Studio 不能够检测到（真机）物理机</h1>\n<p>使用 adb 命令显示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#修改前</span></span><br><span class=\"line\">adb devices</span><br><span class=\"line\">List of devices attached</span><br><span class=\"line\">3ff8c47a        no permissions (user jone is not <span class=\"keyword\">in</span> the plugdev group); see [http://developer.android.com/tools/device.html]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改后 正常显示</span></span><br><span class=\"line\">adb devices</span><br><span class=\"line\">List of devices attached</span><br><span class=\"line\">3ff8c47a        device</span><br></pre></td></tr></table></figure>\n<p>修改方法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> vim /etc/udev/rules.d/android.rules</span><br><span class=\"line\">SUBSYSTEM==<span class=\"string\">&quot;usb&quot;</span>, ENV&#123;DEVTYPE&#125;==<span class=\"string\">&quot;usb_device&quot;</span>, MODE=<span class=\"string\">&quot;0666&quot;</span></span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "android",
                "linux"
            ]
        }
    ]
}